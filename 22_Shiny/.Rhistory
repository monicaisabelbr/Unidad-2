install.packages("dplyr")
install.packages("tidyr")
install.packages("readr")
install.packages("knitr")
install.packages("scales")
library(readxl)  # Para leer archivos .xlsx (Equivalente a pd.read_excel)
library(dplyr)   # Para manipulaci√≥n de datos (Equivalente a pandas)
library(tidyr)   # Para limpieza de datos (e.g., fill)
library(readr)   # Para leer/escribir CSV (Equivalente a pd.to_csv)
library(knitr)   # Para crear tablas en markdown (Equivalente a .to_markdown())
library(scales)  # Para formateo de moneda (e.g., dollar())
install.packages("knitr")
library(readxl)  # Para leer archivos .xlsx (Equivalente a pd.read_excel)
library(dplyr)   # Para manipulaci√≥n de datos (Equivalente a pandas)
library(tidyr)   # Para limpieza de datos (e.g., fill)
library(readr)   # Para leer/escribir CSV (Equivalente a pd.to_csv)
library(knitr)   # Para crear tablas en markdown (Equivalente a .to_markdown())
library(scales)  # Para formateo de moneda (e.g., dollar())
install.packages("scales")
file_path <- "C:/Users/isabe/OneDrive - Universidad Privada del Valle/4TO SEMESTRE/Atrevete/BMW_sales_data_clean.xlsx"
df <- tryCatch({
# Leemos el archivo excel
read_excel(file_path)
}, error = function(e) {
# Manejo de error si no se encuentra el archivo
print("‚ùå ERROR: Aseg√∫rese de que el archivo 'BMW_sales_data_clean.xlsx' est√© en la ruta especificada.")
print(e)
return(NULL)
})
# Continuar solo si el 'df' se carg√≥ correctamente
if (!is.null(df)) {
print("--- üìÇ Archivo cargado correctamente ---")
print(paste("Filas iniciales:", nrow(df)))
print("\n--- Typos iniciales en 'Color' ---")
print(unique(df$Color))
# --- 2. Limpieza de Datos (Data Cleaning) ---
# 1. Gesti√≥n de Registros Duplicados (Equivalente a drop_duplicates)
df <- df %>%
distinct()
print(paste("Filas despu√©s de eliminar duplicados:", nrow(df)))
# 2. Estandarizaci√≥n de Datos Categ√≥ricos (Color)
# Usamos recode() de dplyr, similar al .replace() de pandas
df <- df %>%
mutate(Color = recode(Color,
'Blak' = 'Black',
'Blu' = 'Blue',
'Sliver' = 'Silver',
'Whtie' = 'White',
'Reed' = 'Red'))
print(paste("Valores √∫nicos en 'Color' despu√©s de la correcci√≥n:"))
print(unique(df$Color))
# 3. Imputaci√≥n y Gesti√≥n de Valores Faltantes (Missing Values)
# Usamos group_by y mutate/ifelse, que es la forma idiom√°tica en R
# de hacer un groupby().transform() + fillna()
# Engine_Size_L: Imputaci√≥n por media agrupada
df <- df %>%
group_by(Model, Fuel_Type) %>%
mutate(Engine_Size_L = ifelse(is.na(Engine_Size_L), mean(Engine_Size_L, na.rm = TRUE), Engine_Size_L)) %>%
ungroup() %>%
# Imputaci√≥n global de respaldo (si un grupo entero era NA)
mutate(Engine_Size_L = ifelse(is.na(Engine_Size_L), mean(Engine_Size_L, na.rm = TRUE), Engine_Size_L))
# Mileage_KM: Imputaci√≥n por mediana agrupada por A√±o
df <- df %>%
group_by(Year) %>%
mutate(Mileage_KM = ifelse(is.na(Mileage_KM), median(Mileage_KM, na.rm = TRUE), Mileage_KM)) %>%
ungroup() %>%
mutate(Mileage_KM = ifelse(is.na(Mileage_KM), median(Mileage_KM, na.rm = TRUE), Mileage_KM))
# Price_USD: Imputaci√≥n por mediana agrupada por Modelo y A√±o
df <- df %>%
group_by(Model, Year) %>%
mutate(Price_USD = ifelse(is.na(Price_USD), median(Price_USD, na.rm = TRUE), Price_USD)) %>%
ungroup() %>%
mutate(Price_USD = ifelse(is.na(Price_USD), median(Price_USD, na.rm = TRUE), Price_USD))
# Sales_Volume: Imputaci√≥n por media agrupada por Regi√≥n
df <- df %>%
group_by(Region) %>%
mutate(Sales_Volume = ifelse(is.na(Sales_Volume), mean(Sales_Volume, na.rm = TRUE), Sales_Volume)) %>%
ungroup() %>%
mutate(Sales_Volume = ifelse(is.na(Sales_Volume), mean(Sales_Volume, na.rm = TRUE), Sales_Volume))
print("\nConteo de Valores Faltantes despu√©s de la Imputaci√≥n:")
# Equivalente a df.isnull().sum()
print(sapply(df, function(x) sum(is.na(x))))
# 4. Detecci√≥n y Tratamiento de Outliers (Capping con IQR)
cap_outliers_iqr <- function(series, factor = 1.5) {
# Equivalente a la funci√≥n de Python
Q1 <- quantile(series, 0.25, na.rm = TRUE)
Q3 <- quantile(series, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - factor * IQR
upper_bound <- Q3 + factor * IQR
# Equivalente a .clip() de pandas
series <- ifelse(series < lower_bound, lower_bound, series)
series <- ifelse(series > upper_bound, upper_bound, series)
return(series)
}
# Aplicar capping (usando mutate)
df <- df %>%
mutate(
Engine_Size_L = cap_outliers_iqr(Engine_Size_L),
Price_USD = cap_outliers_iqr(Price_USD),
Mileage_KM = cap_outliers_iqr(Mileage_KM)
)
print("\n--- Estad√≠sticas Descriptivas despu√©s de la Limpieza (Outliers controlados) ---")
# Equivalente a .describe()
print(summary(df[, c('Engine_Size_L', 'Price_USD', 'Mileage_KM')]))
# --- 3. Ingenier√≠a de Caracter√≠sticas (Feature Engineering) y Guardado ---
# 5. Creaci√≥n de Antig√ºedad del Veh√≠culo
current_year <- 2024
df <- df %>%
mutate(Car_Age = current_year - Year)
print("\n--- Primeras 5 filas del DataFrame Limpio y Preparado ---")
print(head(df))
# 6. Guardar el DataFrame limpio
write_csv(df, "BMW_sales_data_clean.csv")
print("\n--- ‚úÖ Archivo limpio guardado como 'BMW_sales_data_clean.csv' ---")
# --- 4. An√°lisis de Negocio y Modelo Predictivo ---
# En R, no es necesario recargar el archivo, podemos seguir usando el 'df'
print("DataFrame limpio cargado correctamente.")
# =========================================================================
# === PREGUNTA 1: PRIORIZACI√ìN GEOGR√ÅFICA PARA VEH√çCULOS PREMIUM (BI) ===
# =========================================================================
cat("\n" + strrep("=", 70))
cat("\n=== 1. An√°lisis de Priorizaci√≥n Geogr√°fica (Veh√≠culos Premium 'High') ===\n")
cat(strrep("=", 70) + "\n")
df_premium <- df %>%
filter(Sales_Classification == 'High')
premium_analysis <- df_premium %>%
group_by(Region) %>%
summarise(
Precio_Promedio_USD = mean(Price_USD, na.rm = TRUE),
Volumen_Total_Ventas = sum(Sales_Volume, na.rm = TRUE)
) %>%
mutate(
Precio_Promedio_USD = round(Precio_Promedio_USD, 2),
Volumen_Total_Ventas = as.integer(Volumen_Total_Ventas)
) %>%
# Ordenar para la decisi√≥n (Equivalente a sort_values)
arrange(desc(Precio_Promedio_USD), desc(Volumen_Total_Ventas))
# Imprimir la tabla en formato markdown
print(kable(premium_analysis, format = "pipe"))
# =========================================================================
# === PREGUNTA 2: MODELO DE VEH√çCULO √ìPTIMO (EQUILIBRIO) ===
# =========================================================================
cat("\n" + strrep("=", 70))
cat("\n=== 2. An√°lisis de Modelo de Veh√≠culo √ìptimo (Equilibrio) ===\n")
cat(strrep("=", 70) + "\n")
# Funci√≥n de normalizaci√≥n Min-Max
min_max_normalize <- function(series) {
min_val <- min(series, na.rm = TRUE)
max_val <- max(series, na.rm = TRUE)
return((series - min_val) / (max_val - min_val))
}
model_analysis <- df %>%
group_by(Model) %>%
summarise(
Volumen_Total_Ventas = sum(Sales_Volume, na.rm = TRUE),
Precio_Promedio_USD = mean(Price_USD, na.rm = TRUE),
Desviacion_Estandar_Precio = sd(Price_USD, na.rm = TRUE),
Desviacion_Estandar_Kilometraje = sd(Mileage_KM, na.rm = TRUE)
) %>%
mutate(
# Coeficiente de Variaci√≥n (CV)
Coeficiente_Variacion_Precio = Desviacion_Estandar_Precio / Precio_Promedio_USD,
# Normalizar las m√©tricas
Norm_Volumen_Total_Ventas = min_max_normalize(Volumen_Total_Ventas),
Norm_Coeficiente_Variacion_Precio = min_max_normalize(Coeficiente_Variacion_Precio),
Norm_Desviacion_Estandar_Kilometraje = min_max_normalize(Desviacion_Estandar_Kilometraje),
# Puntuaci√≥n de Equilibrio
Puntuacion_Equilibrio = Norm_Volumen_Total_Ventas -
Norm_Coeficiente_Variacion_Precio -
Norm_Desviacion_Estandar_Kilometraje
) %>%
# Seleccionar columnas finales
select(
Model,
Volumen_Total_Ventas,
Coeficiente_Variacion_Precio,
Desviacion_Estandar_Kilometraje,
Puntuacion_Equilibrio
) %>%
arrange(desc(Puntuacion_Equilibrio))
# Imprimir la tabla en formato markdown
print(kable(model_analysis, format = "pipe", digits = 4))
# =========================================================================
# === PREGUNTA 3: PRECIO DE REVENTA √ìPTIMO (MODELO PREDICTIVO) ===
# =========================================================================
cat("\n" + strrep("=", 70))
cat("\n=== 3. Predicci√≥n de Precio de Reventa √ìptimo (Regresi√≥n Lineal) ===\n")
cat(strrep("=", 70) + "\n")
# 1. Preparaci√≥n de datos
# Convertir categ√≥ricas a factores. lm() las manejar√° como dummies.
df_ml <- df %>%
mutate(across(c(Fuel_Type, Transmission, Region), as.factor))
# 2. Estandarizaci√≥n de variables num√©ricas
# Guardamos las medias y DE para usarlas en la predicci√≥n (equiv a scaler.fit)
numerical_cols <- c('Mileage_KM', 'Engine_Size_L', 'Car_Age')
scalers <- list(
mean = sapply(df_ml[numerical_cols], mean, na.rm = TRUE),
sd = sapply(df_ml[numerical_cols], sd, na.rm = TRUE)
)
# Estandarizamos el dataframe (equiv a scaler.transform)
# Usamos scale()[,] para obtener el vector
df_ml_scaled <- df_ml %>%
mutate(across(all_of(numerical_cols), ~ scale(.)[, 1]))
# 3. Entrenamiento del Modelo (Equivalente a LinearRegression.fit)
# lm() maneja el One-Hot Encoding (drop_first=True por defecto)
model <- lm(Price_USD ~ Mileage_KM + Engine_Size_L + Car_Age +
Fuel_Type + Transmission + Region,
data = df_ml_scaled)
# 4. Definici√≥n del Escenario de Predicci√≥n
# Escenario: 80,000 km, Motor 3.0L, 5 a√±os, Gasolina, Autom√°tico.
# Funci√≥n para crear el data frame del escenario
create_scenario <- function(region_name) {
data.frame(
Mileage_KM = 80000,
Engine_Size_L = 3.0,
Car_Age = 5,
# Aseguramos que los niveles del factor coincidan con los datos de entrenamiento
Fuel_Type = factor("Petrol", levels = levels(df_ml$Fuel_Type)),
Transmission = factor("Automatic", levels = levels(df_ml$Transmission)),
Region = factor(region_name, levels = levels(df_ml$Region))
)
}
# Funci√≥n para estandarizar los nuevos datos con los 'scalers' guardados
scale_new_data <- function(new_data, scalers) {
for (col in names(scalers$mean)) {
new_data[[col]] <- (new_data[[col]] - scalers$mean[col]) / scalers$sd[col]
}
return(new_data)
}
# Preparar inputs para Europa y Norteam√©rica
scenario_europe <- create_scenario("Europe")
scenario_na <- create_scenario("North America")
# Estandarizar los escenarios
scenario_europe_scaled <- scale_new_data(scenario_europe, scalers)
scenario_na_scaled <- scale_new_data(scenario_na, scalers)
# 5. Predicci√≥n (Equivalente a model.predict)
pred_europe <- predict(model, newdata = scenario_europe_scaled)
pred_na <- predict(model, newdata = scenario_na_scaled)
cat(f"Escenario: Usado, 80,000 km, Motor 3.0L, 5 a√±os, Gasolina, Autom√°tico.\n")
library(readxl)  # Para leer archivos .xlsx (Equivalente a pd.read_excel)
library(dplyr)   # Para manipulaci√≥n de datos (Equivalente a pandas)
library(tidyr)   # Para limpieza de datos (e.g., fill)
library(readr)   # Para leer/escribir CSV (Equivalente a pd.to_csv)
library(knitr)   # Para crear tablas en markdown (Equivalente a .to_markdown())
library(scales)  # Para formateo de moneda (e.g., dollar())
install.packages("scales")
file_path <- "C:/Users/isabe/OneDrive - Universidad Privada del Valle/4TO SEMESTRE/Atrevete/BMW_sales_data_clean.xlsx"
df <- tryCatch({
# Leemos el archivo excel
read_excel(file_path)
}, error = function(e) {
# Manejo de error si no se encuentra el archivo
print("‚ùå ERROR: Aseg√∫rese de que el archivo 'BMW_sales_data_clean.xlsx' est√© en la ruta especificada.")
print(e)
return(NULL)
})
# Continuar solo si el 'df' se carg√≥ correctamente
if (!is.null(df)) {
print("--- üìÇ Archivo cargado correctamente ---")
print(paste("Filas iniciales:", nrow(df)))
print("\n--- Typos iniciales en 'Color' ---")
print(unique(df$Color))
# --- 2. Limpieza de Datos (Data Cleaning) ---
# 1. Gesti√≥n de Registros Duplicados (Equivalente a drop_duplicates)
df <- df %>%
distinct()
print(paste("Filas despu√©s de eliminar duplicados:", nrow(df)))
# 2. Estandarizaci√≥n de Datos Categ√≥ricos (Color)
# Usamos recode() de dplyr, similar al .replace() de pandas
df <- df %>%
mutate(Color = recode(Color,
'Blak' = 'Black',
'Blu' = 'Blue',
'Sliver' = 'Silver',
'Whtie' = 'White',
'Reed' = 'Red'))
print(paste("Valores √∫nicos en 'Color' despu√©s de la correcci√≥n:"))
print(unique(df$Color))
# 3. Imputaci√≥n y Gesti√≥n de Valores Faltantes (Missing Values)
# Usamos group_by y mutate/ifelse, que es la forma idiom√°tica en R
# de hacer un groupby().transform() + fillna()
# Engine_Size_L: Imputaci√≥n por media agrupada
df <- df %>%
group_by(Model, Fuel_Type) %>%
mutate(Engine_Size_L = ifelse(is.na(Engine_Size_L), mean(Engine_Size_L, na.rm = TRUE), Engine_Size_L)) %>%
ungroup() %>%
# Imputaci√≥n global de respaldo (si un grupo entero era NA)
mutate(Engine_Size_L = ifelse(is.na(Engine_Size_L), mean(Engine_Size_L, na.rm = TRUE), Engine_Size_L))
# Mileage_KM: Imputaci√≥n por mediana agrupada por A√±o
df <- df %>%
group_by(Year) %>%
mutate(Mileage_KM = ifelse(is.na(Mileage_KM), median(Mileage_KM, na.rm = TRUE), Mileage_KM)) %>%
ungroup() %>%
mutate(Mileage_KM = ifelse(is.na(Mileage_KM), median(Mileage_KM, na.rm = TRUE), Mileage_KM))
# Price_USD: Imputaci√≥n por mediana agrupada por Modelo y A√±o
df <- df %>%
group_by(Model, Year) %>%
mutate(Price_USD = ifelse(is.na(Price_USD), median(Price_USD, na.rm = TRUE), Price_USD)) %>%
ungroup() %>%
mutate(Price_USD = ifelse(is.na(Price_USD), median(Price_USD, na.rm = TRUE), Price_USD))
# Sales_Volume: Imputaci√≥n por media agrupada por Regi√≥n
df <- df %>%
group_by(Region) %>%
mutate(Sales_Volume = ifelse(is.na(Sales_Volume), mean(Sales_Volume, na.rm = TRUE), Sales_Volume)) %>%
ungroup() %>%
mutate(Sales_Volume = ifelse(is.na(Sales_Volume), mean(Sales_Volume, na.rm = TRUE), Sales_Volume))
print("\nConteo de Valores Faltantes despu√©s de la Imputaci√≥n:")
# Equivalente a df.isnull().sum()
print(sapply(df, function(x) sum(is.na(x))))
# 4. Detecci√≥n y Tratamiento de Outliers (Capping con IQR)
cap_outliers_iqr <- function(series, factor = 1.5) {
# Equivalente a la funci√≥n de Python
Q1 <- quantile(series, 0.25, na.rm = TRUE)
Q3 <- quantile(series, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - factor * IQR
upper_bound <- Q3 + factor * IQR
# Equivalente a .clip() de pandas
series <- ifelse(series < lower_bound, lower_bound, series)
series <- ifelse(series > upper_bound, upper_bound, series)
return(series)
}
# Aplicar capping (usando mutate)
df <- df %>%
mutate(
Engine_Size_L = cap_outliers_iqr(Engine_Size_L),
Price_USD = cap_outliers_iqr(Price_USD),
Mileage_KM = cap_outliers_iqr(Mileage_KM)
)
print("\n--- Estad√≠sticas Descriptivas despu√©s de la Limpieza (Outliers controlados) ---")
# Equivalente a .describe()
print(summary(df[, c('Engine_Size_L', 'Price_USD', 'Mileage_KM')]))
# --- 3. Ingenier√≠a de Caracter√≠sticas (Feature Engineering) y Guardado ---
# 5. Creaci√≥n de Antig√ºedad del Veh√≠culo
current_year <- 2024
df <- df %>%
mutate(Car_Age = current_year - Year)
print("\n--- Primeras 5 filas del DataFrame Limpio y Preparado ---")
print(head(df))
# 6. Guardar el DataFrame limpio
write_csv(df, "BMW_sales_data_clean.csv")
print("\n--- ‚úÖ Archivo limpio guardado como 'BMW_sales_data_clean.csv' ---")
# --- 4. An√°lisis de Negocio y Modelo Predictivo ---
# En R, no es necesario recargar el archivo, podemos seguir usando el 'df'
print("DataFrame limpio cargado correctamente.")
# =========================================================================
# === PREGUNTA 1: PRIORIZACI√ìN GEOGR√ÅFICA PARA VEH√çCULOS PREMIUM (BI) ===
# =========================================================================
cat("\n" , strrep("=", 70))
cat("\n=== 1. An√°lisis de Priorizaci√≥n Geogr√°fica (Veh√≠culos Premium 'High') ===\n")
cat(strrep("=", 70) , "\n")
df_premium <- df %>%
filter(Sales_Classification == 'High')
premium_analysis <- df_premium %>%
group_by(Region) %>%
summarise(
Precio_Promedio_USD = mean(Price_USD, na.rm = TRUE),
Volumen_Total_Ventas = sum(Sales_Volume, na.rm = TRUE)
) %>%
mutate(
Precio_Promedio_USD = round(Precio_Promedio_USD, 2),
Volumen_Total_Ventas = as.integer(Volumen_Total_Ventas)
) %>%
# Ordenar para la decisi√≥n (Equivalente a sort_values)
arrange(desc(Precio_Promedio_USD), desc(Volumen_Total_Ventas))
# Imprimir la tabla en formato markdown
print(kable(premium_analysis, format = "pipe"))
# =========================================================================
# === PREGUNTA 2: MODELO DE VEH√çCULO √ìPTIMO (EQUILIBRIO) ===
# =========================================================================
cat("\n" , strrep("=", 70))
cat("\n=== 2. An√°lisis de Modelo de Veh√≠culo √ìptimo (Equilibrio) ===\n")
cat(strrep("=", 70) , "\n")
# Funci√≥n de normalizaci√≥n Min-Max
min_max_normalize <- function(series) {
min_val <- min(series, na.rm = TRUE)
max_val <- max(series, na.rm = TRUE)
return((series - min_val) / (max_val - min_val))
}
model_analysis <- df %>%
group_by(Model) %>%
summarise(
Volumen_Total_Ventas = sum(Sales_Volume, na.rm = TRUE),
Precio_Promedio_USD = mean(Price_USD, na.rm = TRUE),
Desviacion_Estandar_Precio = sd(Price_USD, na.rm = TRUE),
Desviacion_Estandar_Kilometraje = sd(Mileage_KM, na.rm = TRUE)
) %>%
mutate(
# Coeficiente de Variaci√≥n (CV)
Coeficiente_Variacion_Precio = Desviacion_Estandar_Precio / Precio_Promedio_USD,
# Normalizar las m√©tricas
Norm_Volumen_Total_Ventas = min_max_normalize(Volumen_Total_Ventas),
Norm_Coeficiente_Variacion_Precio = min_max_normalize(Coeficiente_Variacion_Precio),
Norm_Desviacion_Estandar_Kilometraje = min_max_normalize(Desviacion_Estandar_Kilometraje),
# Puntuaci√≥n de Equilibrio
Puntuacion_Equilibrio = Norm_Volumen_Total_Ventas -
Norm_Coeficiente_Variacion_Precio -
Norm_Desviacion_Estandar_Kilometraje
) %>%
# Seleccionar columnas finales
select(
Model,
Volumen_Total_Ventas,
Coeficiente_Variacion_Precio,
Desviacion_Estandar_Kilometraje,
Puntuacion_Equilibrio
) %>%
arrange(desc(Puntuacion_Equilibrio))
# Imprimir la tabla en formato markdown
print(kable(model_analysis, format = "pipe", digits = 4))
# =========================================================================
# === PREGUNTA 3: PRECIO DE REVENTA √ìPTIMO (MODELO PREDICTIVO) ===
# =========================================================================
cat("\n" , strrep("=", 70))
cat("\n=== 3. Predicci√≥n de Precio de Reventa √ìptimo (Regresi√≥n Lineal) ===\n")
cat(strrep("=", 70) , "\n")
# 1. Preparaci√≥n de datos
# Convertir categ√≥ricas a factores. lm() las manejar√° como dummies.
df_ml <- df %>%
mutate(across(c(Fuel_Type, Transmission, Region), as.factor))
# 2. Estandarizaci√≥n de variables num√©ricas
# Guardamos las medias y DE para usarlas en la predicci√≥n (equiv a scaler.fit)
numerical_cols <- c('Mileage_KM', 'Engine_Size_L', 'Car_Age')
scalers <- list(
mean = sapply(df_ml[numerical_cols], mean, na.rm = TRUE),
sd = sapply(df_ml[numerical_cols], sd, na.rm = TRUE)
)
# Estandarizamos el dataframe (equiv a scaler.transform)
# Usamos scale()[,] para obtener el vector
df_ml_scaled <- df_ml %>%
mutate(across(all_of(numerical_cols), ~ scale(.)[, 1]))
# 3. Entrenamiento del Modelo (Equivalente a LinearRegression.fit)
# lm() maneja el One-Hot Encoding (drop_first=True por defecto)
model <- lm(Price_USD ~ Mileage_KM + Engine_Size_L + Car_Age +
Fuel_Type + Transmission + Region,
data = df_ml_scaled)
# 4. Definici√≥n del Escenario de Predicci√≥n
# Escenario: 80,000 km, Motor 3.0L, 5 a√±os, Gasolina, Autom√°tico.
# Funci√≥n para crear el data frame del escenario
create_scenario <- function(region_name) {
data.frame(
Mileage_KM = 80000,
Engine_Size_L = 3.0,
Car_Age = 5,
# Aseguramos que los niveles del factor coincidan con los datos de entrenamiento
Fuel_Type = factor("Petrol", levels = levels(df_ml$Fuel_Type)),
Transmission = factor("Automatic", levels = levels(df_ml$Transmission)),
Region = factor(region_name, levels = levels(df_ml$Region))
)
}
# Funci√≥n para estandarizar los nuevos datos con los 'scalers' guardados
scale_new_data <- function(new_data, scalers) {
for (col in names(scalers$mean)) {
new_data[[col]] <- (new_data[[col]] - scalers$mean[col]) / scalers$sd[col]
}
return(new_data)
}
# Preparar inputs para Europa y Norteam√©rica
scenario_europe <- create_scenario("Europe")
scenario_na <- create_scenario("North America")
# Estandarizar los escenarios
scenario_europe_scaled <- scale_new_data(scenario_europe, scalers)
scenario_na_scaled <- scale_new_data(scenario_na, scalers)
# 5. Predicci√≥n (Equivalente a model.predict)
pred_europe <- predict(model, newdata = scenario_europe_scaled)
pred_na <- predict(model, newdata = scenario_na_scaled)
cat(paste0("Escenario: Usado, 80,000 km, Motor 3.0L, 5 a√±os, Gasolina, Autom√°tico.\n"))
# Usamos scales::dollar() para formatear la moneda
cat(paste0("Precio de Reventa √ìptimo (Europa): ", dollar(pred_europe), "\n"))
cat(paste0("Precio de Reventa √ìptimo (Norteam√©rica): ", dollar(pred_na), "\n"))
} # Fin del bloque if (!is.null(df))
generar_poblacion <- function(seed, n, p) {
set.seed(seed)
rbinom(n, 1, p)
}
tomar_muestra <- function(poblacion, n_muestra) {
sample(poblacion, n_muestra, replace=FALSE)
}
calcular_proporcion <- function(muestra) {
sum(muestra) / length(muestra)
}
rbinom(1000,¬†1,¬†0.5)
generar_poblacion <- function(seed, n, p) {
set.seed(seed)
rbinom(n, 1, p)
}
tomar_muestra <- function(poblacion, n_muestra) {
sample(poblacion, n_muestra, replace=FALSE)
}
calcular_proporcion <- function(muestra) {
sum(muestra) / length(muestra)
}
rbinom(1000,1,0.5)
tomar_muestra(x,100)
x = generar_poblacion(123,1000,0.3)
tomar_muestra(x, 100)
y = tomar_muestra(x, 100)
calcular_proporcion(y)
y = tomar_muestra(x, 100)
calcular_proporcion(y)
table(x)
295/1000
prop.table(table(x))
library(shiny); runApp('C:/Users/isabe/OneDrive - Universidad Privada del Valle/4TO SEMESTRE/ESTADISTICA IV/Unidad 2/22_Shiny/app2.R')
library(rsconnect)
rsconnect::setAccountInfo(name='monicaisabelbr',
token='F727C9F5C74D2A4D54C678903BE2DC6D',
secret='PwDlG6FwtCLHiHl8Uxt6tZW2rpafrCp+o3Uw4U1N')
rsconnect::deployApp(appDir = "C:/Users/isabe/OneDrive - Universidad Privada del Valle/4TO SEMESTRE/ESTADISTICA IV/Unidad 2/22_Shiny",
appName = "22_myapp")
shiny::runApp('C:/Users/isabe/OneDrive - Universidad Privada del Valle/4TO SEMESTRE/ESTADISTICA IV/Unidad 2/22_Shiny')
